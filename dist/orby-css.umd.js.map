{"version":3,"file":"orby-css.umd.js","sources":["../src/parse.js","../src/index.js"],"sourcesContent":["export function trim(str) {\r\n    return str.trim ? str.trim() : str.replace(/^\\s*|\\s*$/, \"\");\r\n}\r\n\r\nexport function isProperty(string) {\r\n    return string.match(/([^\\:]+):(.+)(;){0,1}$/);\r\n}\r\n\r\nexport default function mapSelector(string) {\r\n    let name = \"\",\r\n        open = 0,\r\n        parts = [],\r\n        args = [],\r\n        prev;\r\n    for (let i = 0; i < string.length; i++) {\r\n        let letter = string[i];\r\n        if (letter === \"(\") {\r\n            if (!open++) {\r\n                args = [];\r\n                prev = name;\r\n                name = \"\";\r\n            } else {\r\n                name += letter;\r\n            }\r\n        } else if (letter === \")\") {\r\n            if (!--open) {\r\n                args.push(name);\r\n                parts.push({\r\n                    name: prev,\r\n                    args\r\n                });\r\n                name = \"\";\r\n                args = [];\r\n            } else {\r\n                name += letter;\r\n            }\r\n        } else {\r\n            if (letter === \",\") {\r\n                name && (open ? args.push(name) : parts.push({ name }));\r\n                name = \"\";\r\n            } else {\r\n                name += letter;\r\n            }\r\n        }\r\n    }\r\n    if (name) parts.push({ name, args });\r\n    return parts;\r\n}\r\n\r\nexport function createType(selector) {\r\n    selector = trim(selector);\r\n    let children = [],\r\n        properties = [],\r\n        data = { selector, children, type: \"selector\", properties },\r\n        test = selector.match(/^\\@(\\w+) (.+)/);\r\n\r\n    if (test) {\r\n        let [selector, type, value] = test;\r\n        return { selector, type, value, children, properties };\r\n    } else {\r\n        data.selectors = mapSelector(data.selector);\r\n    }\r\n\r\n    return data;\r\n}\r\n\r\nexport function parse(str) {\r\n    let letter,\r\n        current = \"\",\r\n        content = \"\",\r\n        brackets = 0,\r\n        groups = [],\r\n        withSlash,\r\n        currentGroup,\r\n        singleQuote = 0,\r\n        doubleQuote = 0,\r\n        subGroups = [];\r\n\r\n    str = trim(str).replace(/([^\\:]+):([^\\;]+){0,1}}/g, \"$1:$2;}\");\r\n    for (let i = 0; i < str.length; i++) {\r\n        letter = str[i];\r\n        withSlash = str[i - 1] === \"\\\\\";\r\n        if (\r\n            withSlash ||\r\n            ((!/\\\"|\\'/.test(letter) && singleQuote) || doubleQuote)\r\n        ) {\r\n            current += letter;\r\n            continue;\r\n        }\r\n        switch (letter) {\r\n            case \";\":\r\n                if (/\\{/.test(current)) {\r\n                    current += letter;\r\n                } else {\r\n                    let [all, index, value] =\r\n                        current.match(/([^\\:]+):(.+)/) || [];\r\n                    if (index && value) {\r\n                        currentGroup.properties.push({\r\n                            index: trim(index),\r\n                            value: trim(value)\r\n                        });\r\n                        current = \"\";\r\n                    }\r\n                }\r\n                break;\r\n            case \"{\":\r\n                if (!brackets++) {\r\n                    currentGroup = createType(current);\r\n                    groups.push(currentGroup);\r\n                    current = \"\";\r\n                } else {\r\n                    current += letter;\r\n                }\r\n                break;\r\n            case \"}\":\r\n                if (!--brackets) {\r\n                    let children = [];\r\n                    for (let i = 0; i < subGroups.length; i++) {\r\n                        children = children.concat(parse(subGroups[i]));\r\n                    }\r\n                    currentGroup.children = children;\r\n                    subGroups = [];\r\n                } else {\r\n                    subGroups.push((current += letter));\r\n                }\r\n                current = \"\";\r\n                break;\r\n            case \"'\":\r\n                singleQuote ? singleQuote-- : singleQuote++;\r\n                current += letter;\r\n                break;\r\n            case '\"':\r\n                doubleQuote ? doubleQuote-- : doubleQuote++;\r\n                current += letter;\r\n                break;\r\n            default:\r\n                current += letter;\r\n        }\r\n    }\r\n    return groups;\r\n}\r\n","import { parse } from \"./parse\";\r\n\r\nlet counter = 0;\r\nlet prefix = \"css-\";\r\nlet regId = /<<id>>/g;\r\nlet regNm = /<<(?:\\:){0,1}(\\d+)>>(\\;){0,1}/g;\r\nlet strId = \"<<id>>\";\r\n\r\nfunction scoped(rules, id, prefix, deep) {\r\n    rules = rules.map(rule => {\r\n        let selectors, properties;\r\n        switch (rule.type) {\r\n            case \"keyframes\":\r\n                selectors = \"@keyframes \" + id + \"-\" + rule.value;\r\n                properties = properties = scoped(rule.children, \"\", \"\", true);\r\n                return `${selectors}{${properties}}`;\r\n            case \"media\":\r\n                selectors = \"@media \" + rule.value;\r\n                properties = scoped(rule.children, id, prefix, true);\r\n                return `${selectors}{${properties}}`;\r\n            case \"selector\":\r\n                selectors = rule.selectors\r\n                    .map(selector => {\r\n                        let name = selector.name;\r\n                        if (/:host/.test(selector.name)) {\r\n                            if (selector.args.length) {\r\n                                name = selector.args\r\n                                    .map(arg => `${selector.name}${arg}`)\r\n                                    .join(\",\");\r\n                            }\r\n                        }\r\n                        if (/:global/.test(selector.name)) {\r\n                            name = selector.args.join(\",\");\r\n                        }\r\n                        return name.replace(/:host/g, prefix + id);\r\n                    })\r\n                    .join(\",\");\r\n                properties = rule.properties\r\n                    .map(({ index, value }) => {\r\n                        if (/^animation(-name){0,1}$/.test(index)) {\r\n                            value = value.replace(/(\\s*)/, id + \"-$1\");\r\n                        }\r\n                        return `${index}:${value}`;\r\n                    })\r\n                    .join(\";\");\r\n\r\n                return `${selectors}{${properties}}`;\r\n            case \"import\":\r\n                return rule.selector + \";\";\r\n            default:\r\n                return \"\";\r\n        }\r\n    });\r\n    if (!deep) {\r\n        let globals = \"\",\r\n            locals = \"\";\r\n        rules.forEach(str => {\r\n            if (regNm.test(str)) {\r\n                locals += str;\r\n            } else {\r\n                globals += str;\r\n            }\r\n        });\r\n        return { globals, locals };\r\n    }\r\n    return rules.join(\"\");\r\n}\r\n\r\nfunction createGlobal(id, style) {\r\n    let tag = document.querySelector(`style${id}`);\r\n    if (!tag) {\r\n        tag = document.createElement(\"style\");\r\n        document.head.append(tag);\r\n    }\r\n    tag.innerHTML = style.replace(regId, id);\r\n}\r\n\r\nexport default function create(pragma) {\r\n    return function styled(tag, keysProps = []) {\r\n        let element = document.createElement(tag);\r\n        return function local(template, ...args) {\r\n            let idGlobal = prefix + counter++,\r\n                counterLocal = 0;\r\n\r\n            template = template\r\n                .map((string, index) => {\r\n                    if (typeof args[index] === \"function\") {\r\n                        string += /\\:(\\s+)$/.test(string)\r\n                            ? `<<${index}>>`\r\n                            : `<<:${index}>>;`;\r\n                    } else {\r\n                        string += args[index] || \"\";\r\n                    }\r\n                    return string;\r\n                })\r\n                .join(\"\");\r\n            let { globals, locals } = scoped(parse(template), strId, \".\");\r\n            createGlobal(idGlobal, globals);\r\n            return function component(props, context, optional) {\r\n                let idLocal = idGlobal + \"-\" + counterLocal++,\r\n                    style = locals.replace(regId, idLocal).replace(\r\n                        regNm,\r\n                        (all, index, end) =>\r\n                            args[index](props, optional || context, {\r\n                                idGlobal,\r\n                                idLocal\r\n                            }) + (end || \"\")\r\n                    ),\r\n                    nextProps = {\r\n                        class: `${idGlobal} ${idLocal} ${props.class || \"\"}`\r\n                    };\r\n                for (let key in props) {\r\n                    if (\r\n                        key in element ||\r\n                        typeof props[key] === \"function\" ||\r\n                        keysProps.indexOf(key) > -1\r\n                    ) {\r\n                        nextProps[key] = props[key];\r\n                    }\r\n                }\r\n                return pragma(\r\n                    tag,\r\n                    nextProps,\r\n                    pragma(\"style\", {}, style),\r\n                    ...props.children\r\n                );\r\n            };\r\n        };\r\n    };\r\n}\r\n"],"names":["trim","str","replace","createType","selector","children","properties","data","type","test","match","selectors","string","prev","name","open","parts","args","i","length","letter","push","mapSelector","let","counter","prefix","regId","regNm","strId","pragma","tag","keysProps","element","document","createElement","template","idGlobal","counterLocal","scoped","rules","id","deep","map","rule","value","arg","join","ref","index","globals","locals","forEach","parse","currentGroup","current","content","groups","singleQuote","doubleQuote","subGroups","brackets","concat","style","querySelector","head","append","innerHTML","createGlobal","props","context","optional","idLocal","all","end","nextProps","class","key","indexOf"],"mappings":"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"}