{"version":3,"file":"orby-css.umd.js","sources":["../src/options.js","../src/parse.js","../src/index.js"],"sourcesContent":["export let options = {};\r\n","export function trim(str) {\r\n    return str.trim\r\n        ? str.trim()\r\n        : str.replace(/^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g, \"\");\r\n}\r\n\r\nexport function mapSelector(string) {\r\n    string = trim(string);\r\n    let length = string.length,\r\n        letter = \"\",\r\n        openArgs = 0,\r\n        selector = [],\r\n        selectors = [],\r\n        currentArgs = \"\",\r\n        singleQuote = 0,\r\n        doubleQuote = 0,\r\n        state = { value: \"\", args: [] },\r\n        insertSelector = selector =>\r\n            selectors.indexOf(selector) === -1 && selectors.push(selector),\r\n        insertState = state =>\r\n            selector.indexOf(state) === -1 && selector.push(state);\r\n\r\n    insertState(state);\r\n\r\n    for (let index = 0; index < length; index++) {\r\n        letter = string[index];\r\n        if (singleQuote || doubleQuote) {\r\n            currentArgs += letter;\r\n            if (letter === \"'\" || letter === '\"') {\r\n                if (letter === \"'\") {\r\n                    singleQuote = false;\r\n                } else {\r\n                    doubleQuote = false;\r\n                }\r\n            }\r\n            continue;\r\n        }\r\n        switch (letter) {\r\n            case \":\":\r\n                if (string[index - 1] === \":\") {\r\n                    state.value += \":\";\r\n                } else {\r\n                    if (state.value) {\r\n                        insertState(state);\r\n                        insertState(\r\n                            (state = {\r\n                                value: \":\",\r\n                                args: []\r\n                            })\r\n                        );\r\n                    } else {\r\n                        state.value = \":\";\r\n                    }\r\n                }\r\n                currentArgs = \"\";\r\n                break;\r\n            case \"(\":\r\n            case \")\":\r\n                if (letter == \"(\") {\r\n                    if (!openArgs++) {\r\n                        currentArgs = \"\";\r\n                    }\r\n                } else {\r\n                    if (!--openArgs) {\r\n                        state.args.push(currentArgs);\r\n                        currentArgs = \"\";\r\n                    }\r\n                }\r\n                break;\r\n            case \"'\":\r\n            case '\"':\r\n                if (letter === \"'\") {\r\n                    singleQuote++;\r\n                } else {\r\n                    doubleQuote++;\r\n                }\r\n                currentArgs += letter;\r\n                break;\r\n            case \",\":\r\n                if (openArgs) {\r\n                    state.args.push(currentArgs);\r\n                    currentArgs = \"\";\r\n                } else {\r\n                    if (selector.length) {\r\n                        insertSelector(selector);\r\n                    }\r\n                    if (state.value) {\r\n                        insertState(state);\r\n                    }\r\n                    insertSelector(\r\n                        (selector = [\r\n                            (state = {\r\n                                value: \"\",\r\n                                args: []\r\n                            })\r\n                        ])\r\n                    );\r\n                }\r\n                break;\r\n\r\n            case \"\\n\":\r\n                continue;\r\n            default:\r\n                if (openArgs) {\r\n                    currentArgs += letter;\r\n                } else {\r\n                    state.value += letter;\r\n                }\r\n        }\r\n    }\r\n    if (state.value) insertState(state);\r\n    if (selector.length) insertSelector(selector);\r\n    return selectors;\r\n}\r\n\r\nexport function createType(selector) {\r\n    selector = trim(selector);\r\n    let children = [],\r\n        properties = [],\r\n        data = { selector, children, type: \"selector\", properties },\r\n        test = selector.match(/^\\@(\\w+) (.+)/);\r\n\r\n    if (test) {\r\n        let [selector, type, value] = test;\r\n        return { selector, type, value, children, properties };\r\n    } else {\r\n        data.selectors = mapSelector(data.selector);\r\n    }\r\n\r\n    return data;\r\n}\r\n/**\r\n *\r\n * @param {String} str - css rules\r\n * @return {Array}\r\n *\r\n * TODO:\r\n * Add support:\r\n * selector{color:'every:a;{}'}\r\n */\r\nexport function parse(str) {\r\n    let letter,\r\n        current = \"\",\r\n        content = \"\",\r\n        brackets = 0,\r\n        groups = [],\r\n        withSlash,\r\n        currentGroup,\r\n        singleQuote = 0,\r\n        doubleQuote = 0,\r\n        subGroups = [];\r\n\r\n    str = trim(str).replace(/([^\\:]+):([^\\;]+){0,1}}/g, \"$1:$2;}\");\r\n    for (let i = 0; i < str.length; i++) {\r\n        letter = str[i];\r\n\r\n        if (str[i - 1] === \"\\\\\") {\r\n            current += letter;\r\n            continue;\r\n        }\r\n\r\n        if (singleQuote || doubleQuote) {\r\n            current += letter;\r\n            if (letter === \"'\" || letter === '\"') {\r\n                if (letter === \"'\") {\r\n                    singleQuote = false;\r\n                } else {\r\n                    doubleQuote = false;\r\n                }\r\n            }\r\n            continue;\r\n        }\r\n        switch (letter) {\r\n            case \";\":\r\n                if (!/\\{/.test(current)) {\r\n                    current = trim(current);\r\n                    let [all, index, value] =\r\n                        current.match(/^([\\w\\<\\-]+)(?:\\s*):(.+)/) || [];\r\n                    if (index && value) {\r\n                        currentGroup.properties.push({\r\n                            index,\r\n                            value: trim(value)\r\n                        });\r\n                    } else {\r\n                        current && groups.push(createType(current));\r\n                    }\r\n                    current = \"\";\r\n                } else {\r\n                    current += letter;\r\n                }\r\n                break;\r\n            case \"{\":\r\n                if (!brackets++) {\r\n                    currentGroup = createType(current);\r\n                    groups.push(currentGroup);\r\n                    current = \"\";\r\n                } else {\r\n                    current += letter;\r\n                }\r\n                break;\r\n            case \"}\":\r\n                if (!--brackets) {\r\n                    let children = [];\r\n                    for (let i = 0; i < subGroups.length; i++) {\r\n                        children = children.concat(parse(subGroups[i]));\r\n                    }\r\n                    currentGroup.children = children;\r\n                    subGroups = [];\r\n                } else {\r\n                    subGroups.push((current += letter));\r\n                }\r\n                current = \"\";\r\n                break;\r\n            case \"'\":\r\n                singleQuote = true;\r\n                current += letter;\r\n                break;\r\n            case '\"':\r\n                doubleQuote = true;\r\n                current += letter;\r\n                break;\r\n            default:\r\n                current += letter;\r\n        }\r\n    }\r\n    return groups;\r\n}\r\n","import { options } from \"./options\";\r\nimport { parse } from \"./parse\";\r\nexport { parse } from \"./parse\";\r\nexport { options } from \"./options\";\r\n\r\nlet ID = 0;\r\n\r\nexport function getTagInstance(tagName) {\r\n    let doc = options.document || document;\r\n\r\n    if (!options.HTMLInstances) {\r\n        options.HTMLInstances = {};\r\n    }\r\n\r\n    if (!options.HTMLInstances[tagName]) {\r\n        options.HTMLInstances[tagName] = doc.createElement(tagName);\r\n    }\r\n\r\n    return options.HTMLInstances[tagName];\r\n}\r\n\r\nexport function stateToArgs(states) {\r\n    return states\r\n        .map(\r\n            ({ value, args }) =>\r\n                value + (args.length ? `(${args.join(\",\")})` : \"\")\r\n        )\r\n        .join(\":\");\r\n}\r\n\r\nexport function createRuleSelector(rule, space, parent, deep = 0) {\r\n    let rules = [],\r\n        root = \".\" + space,\r\n        selectors = rule.selectors.map(([{ value, args }, ...states]) => {\r\n            value = value.replace(/(\\s+)$/, \" \");\r\n            switch (value) {\r\n                case \":host\":\r\n                    return args.length ? args.map(value => root + value) : root;\r\n                case \":global\":\r\n                    return args.join(\",\");\r\n                case \"& \":\r\n                case \"&\":\r\n                    return (\r\n                        parent +\r\n                        (value === \"&\" ? \"\" : \" \") +\r\n                        stateToArgs(states)\r\n                    );\r\n                default:\r\n                    return deep\r\n                        ? (parent ? parent + \" \" : \"\") +\r\n                              value +\r\n                              stateToArgs(states)\r\n                        : `${root} ${value + stateToArgs(states)}`;\r\n            }\r\n        }),\r\n        properties = rule.properties.map(({ index, value }) => {\r\n            if (/^animation(-name){0,1}$/.test(index)) {\r\n                value = space + value;\r\n            }\r\n            return `${index}:${value}`;\r\n        });\r\n\r\n    if (properties.length) {\r\n        rules.push(`${selectors.join(\",\")}{${properties.join(\";\")}}`);\r\n    }\r\n    rule.children.map(rule => {\r\n        rule = selectors.map(selector =>\r\n            createRuleSelector(rule, space, selector, deep + 1)\r\n        );\r\n        if (rule.length) rules = rules.concat(...rule);\r\n    });\r\n\r\n    return rules;\r\n}\r\n\r\nexport function createStaticCss(rules, space, parent = \"\") {\r\n    return rules.reduce((nextRules, rule) => {\r\n        switch (rule.type) {\r\n            case \"keyframes\":\r\n                return nextRules.concat(\r\n                    `@keyframes ${space + rule.value}{${rule.children\r\n                        .map(rule => createRuleSelector(rule, space, \"\", 1))\r\n                        .join(\"\")}}`\r\n                );\r\n            case \"media\":\r\n            case \"supports\":\r\n                return nextRules.concat(\r\n                    `@media ${rule.value}{${rule.children\r\n                        .map(rule => createRuleSelector(rule, space))\r\n                        .join(\"\")}}`\r\n                );\r\n            case \"selector\":\r\n                return nextRules.concat(createRuleSelector(rule, space));\r\n            case \"import\":\r\n                return nextRules.concat(rule.selector + \";\");\r\n            default:\r\n                return nextRules;\r\n        }\r\n    }, []);\r\n}\r\n\r\nexport function transpile(mapString, args) {\r\n    let customVars = {},\r\n        space = \"--cn-\" + ID++,\r\n        localID = 0,\r\n        css = mapString\r\n            .map((string, index) => {\r\n                if (typeof args[index] === \"function\") {\r\n                    let name = space + \"-\" + localID++;\r\n                    customVars[name] = args[index];\r\n                    string += `var(${name})`;\r\n                } else {\r\n                    string += args[index] || \"\";\r\n                }\r\n                return string;\r\n            })\r\n            .join(\"\");\r\n    return {\r\n        space,\r\n        rules: createStaticCss(parse(css), space),\r\n        customVars\r\n    };\r\n}\r\n\r\nexport function createStyled(pragma, enableStyleObject) {\r\n    return function scope(tagName) {\r\n        let isComponent = typeof tagName === \"function\",\r\n            tagInstance = isComponent ? {} : getTagInstance(tagName) || {};\r\n\r\n        return function styled(mapString, ...args) {\r\n            let { space, rules, customVars } = transpile(mapString, args),\r\n                doc = options.document || document;\r\n\r\n            let existStyle = doc.getElementById(space),\r\n                style = existStyle || doc.createElement(\"style\");\r\n\r\n            if (!existStyle) {\r\n                style.id = space;\r\n                doc.head.appendChild(style);\r\n            }\r\n\r\n            if (style.sheet && !options.disableSheet) {\r\n                rules.map((rule, index) => style.sheet.insertRule(rule, index));\r\n            } else {\r\n                style.innerHTML = rules.join(\"\");\r\n            }\r\n            return function Component(props, context) {\r\n                let style = enableStyleObject\r\n                        ? typeof props.style === \"object\"\r\n                            ? props.style\r\n                            : {}\r\n                        : typeof props.style == \"string\"\r\n                        ? props.style\r\n                        : \"\",\r\n                    nextProps = {},\r\n                    className = [space];\r\n\r\n                if (props.className || props.class) {\r\n                    className.push(props.className || props.class);\r\n                }\r\n\r\n                for (let index in customVars) {\r\n                    let value = customVars[index](props, context);\r\n                    if (enableStyleObject) {\r\n                        style[index] = value;\r\n                    } else {\r\n                        if (value) style += `${index}:${value};`;\r\n                    }\r\n                }\r\n\r\n                for (let index in props) {\r\n                    if (\r\n                        isComponent ||\r\n                        typeof props[index] === \"function\" ||\r\n                        index in tagInstance\r\n                    ) {\r\n                        nextProps[index] = props[index];\r\n                    }\r\n                }\r\n\r\n                nextProps.className = className.join(\" \");\r\n\r\n                nextProps.style = style;\r\n\r\n                return pragma(tagName, nextProps, props.children);\r\n            };\r\n        };\r\n    };\r\n}\r\n"],"names":["options","trim","str","replace","createType","selector","children","properties","data","type","test","match","selectors","string","length","letter","openArgs","currentArgs","singleQuote","doubleQuote","state","value","args","insertSelector","indexOf","push","insertState","let","index","mapSelector","parse","currentGroup","current","content","groups","subGroups","i","brackets","concat","ID","getTagInstance","tagName","doc","document","HTMLInstances","createElement","stateToArgs","states","map","ref","join","createRuleSelector","rule","space","parent","deep","rules","root","createStaticCss","reduce","nextRules","transpile","mapString","customVars","localID","css","name","pragma","enableStyleObject","isComponent","tagInstance","existStyle","getElementById","style","id","head","appendChild","sheet","disableSheet","insertRule","innerHTML","props","context","nextProps","className","class"],"mappings":"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"}