{"version":3,"file":"orby-css.mjs","sources":["../src/parse.js","../src/index.js"],"sourcesContent":["export function trim(str) {\r\n    return str.trim\r\n        ? str.trim()\r\n        : str.replace(/^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g, \"\");\r\n}\r\n\r\nexport function mapSelector(string) {\r\n    string = trim(string);\r\n    let name = \"\",\r\n        open = 0,\r\n        parts = [],\r\n        args = [],\r\n        prev;\r\n    for (let i = 0; i < string.length; i++) {\r\n        let letter = string[i];\r\n        if (letter === \"(\") {\r\n            if (!open++) {\r\n                args = [];\r\n                prev = name;\r\n                name = \"\";\r\n            } else {\r\n                name += letter;\r\n            }\r\n        } else if (letter === \")\") {\r\n            if (!--open) {\r\n                args.push(name);\r\n                parts.push({\r\n                    name: prev,\r\n                    args\r\n                });\r\n                name = \"\";\r\n                args = [];\r\n            } else {\r\n                name += letter;\r\n            }\r\n        } else {\r\n            if (letter === \",\") {\r\n                name && (open ? args.push(name) : parts.push({ name }));\r\n                name = \"\";\r\n            } else {\r\n                name += letter;\r\n            }\r\n        }\r\n    }\r\n    if (name) parts.push({ name, args });\r\n    return parts;\r\n}\r\n\r\nexport function createType(selector) {\r\n    selector = trim(selector);\r\n    let children = [],\r\n        properties = [],\r\n        data = { selector, children, type: \"selector\", properties },\r\n        test = selector.match(/^\\@(\\w+) (.+)/);\r\n\r\n    if (test) {\r\n        let [selector, type, value] = test;\r\n        return { selector, type, value, children, properties };\r\n    } else {\r\n        data.selectors = mapSelector(data.selector);\r\n    }\r\n\r\n    return data;\r\n}\r\n/**\r\n *\r\n * @param {String} str - css rules\r\n * @return {Array}\r\n *\r\n * TODO:\r\n * Add support:\r\n * selector{color:'every:a;{}'}\r\n */\r\nexport function parse(str) {\r\n    let letter,\r\n        current = \"\",\r\n        content = \"\",\r\n        brackets = 0,\r\n        groups = [],\r\n        withSlash,\r\n        currentGroup,\r\n        singleQuote = 0,\r\n        doubleQuote = 0,\r\n        subGroups = [];\r\n\r\n    str = trim(str).replace(/([^\\:]+):([^\\;]+){0,1}}/g, \"$1:$2;}\");\r\n    for (let i = 0; i < str.length; i++) {\r\n        letter = str[i];\r\n\r\n        if (str[i - 1] === \"\\\\\") {\r\n            current += letter;\r\n            continue;\r\n        }\r\n\r\n        if (singleQuote || doubleQuote) {\r\n            current += letter;\r\n            if (letter === \"'\" || letter === '\"') {\r\n                if (letter === \"'\") {\r\n                    singleQuote = false;\r\n                } else {\r\n                    doubleQuote = false;\r\n                }\r\n            }\r\n            continue;\r\n        }\r\n        switch (letter) {\r\n            case \";\":\r\n                if (!/\\{/.test(current)) {\r\n                    current = trim(current);\r\n                    let [all, index, value] =\r\n                        current.match(/^([\\w\\<\\-]+)(?:\\s*):(.+)/) || [];\r\n                    if (index && value) {\r\n                        currentGroup.properties.push({\r\n                            index,\r\n                            value: trim(value)\r\n                        });\r\n                    } else {\r\n                        current && groups.push(createType(current));\r\n                    }\r\n                    current = \"\";\r\n                } else {\r\n                    current += letter;\r\n                }\r\n                break;\r\n            case \"{\":\r\n                if (!brackets++) {\r\n                    currentGroup = createType(current);\r\n                    groups.push(currentGroup);\r\n                    current = \"\";\r\n                } else {\r\n                    current += letter;\r\n                }\r\n                break;\r\n            case \"}\":\r\n                if (!--brackets) {\r\n                    let children = [];\r\n                    for (let i = 0; i < subGroups.length; i++) {\r\n                        children = children.concat(parse(subGroups[i]));\r\n                    }\r\n                    currentGroup.children = children;\r\n                    subGroups = [];\r\n                } else {\r\n                    subGroups.push((current += letter));\r\n                }\r\n                current = \"\";\r\n                break;\r\n            case \"'\":\r\n                singleQuote = true;\r\n                current += letter;\r\n                break;\r\n            case '\"':\r\n                doubleQuote = true;\r\n                current += letter;\r\n                break;\r\n            default:\r\n                current += letter;\r\n        }\r\n    }\r\n    return groups;\r\n}\r\n","import { parse } from \"./parse\";\r\nexport { parse } from \"./parse\";\r\n\r\nexport let current = {\r\n    index: 0\r\n};\r\n\r\nlet prefix = \"css-\";\r\nlet regId = /<<id>>/g;\r\nlet regNm = /<<(?:\\:){0,1}(\\d+)>>(\\;){0,1}/g;\r\nlet regAn = /^animation(-name){0,1}$/;\r\nlet strId = \"<<id>>\";\r\n\r\nexport function optimizeRules(rules) {\r\n    let locals = [],\r\n        globals = [];\r\n    for (let i = 0; i < rules.length; i++) {\r\n        let { properties, ...rule } = rules[i],\r\n            lengthProperties = properties.length,\r\n            propertiesLocals = [],\r\n            propertiesGlobal = [];\r\n        for (let i = 0; i < lengthProperties; i++) {\r\n            let { value, index } = properties[i],\r\n                local = false;\r\n\r\n            if (regNm.test(value) || regAn.test(index)) {\r\n                local = true;\r\n                propertiesLocals.push({ value, index });\r\n            } else {\r\n                propertiesGlobal.push({ value, index });\r\n            }\r\n        }\r\n\r\n        if (lengthProperties) {\r\n            if (propertiesLocals.length) {\r\n                locals.push({ ...rule, properties: propertiesLocals });\r\n            }\r\n            if (propertiesGlobal.length) {\r\n                globals.push({ ...rule, properties: propertiesGlobal });\r\n            }\r\n        } else {\r\n            switch (rule.type) {\r\n                case \"media\":\r\n                case \"supports\":\r\n                    let children = optimizeRules(rule.children);\r\n                    locals = locals.concat({\r\n                        ...rule,\r\n                        properties: [],\r\n                        children: children.locals\r\n                    });\r\n                    globals = globals.concat({\r\n                        ...rule,\r\n                        properties: [],\r\n                        children: children.globals\r\n                    });\r\n                    break;\r\n                default:\r\n                    globals.push({ ...rule, properties: [] });\r\n            }\r\n        }\r\n    }\r\n    return { globals, locals };\r\n}\r\n\r\nexport function rulesToCss(rules, id, prefix, deep, isKeyframe) {\r\n    if (!deep) {\r\n        let { locals, globals } = optimizeRules(rules);\r\n        rules = locals.concat(globals);\r\n    }\r\n    rules = rules.map(rule => {\r\n        let selectors, properties;\r\n        switch (rule.type) {\r\n            case \"keyframes\":\r\n                selectors = \"@keyframes \" + id + \"-\" + rule.value;\r\n                properties = properties = rulesToCss(\r\n                    rule.children,\r\n                    \"\",\r\n                    \"\",\r\n                    true,\r\n                    true\r\n                );\r\n                return `${selectors}{${properties}}`;\r\n            case \"media\":\r\n                selectors = \"@media \" + rule.value;\r\n                properties = rulesToCss(rule.children, id, prefix, true);\r\n                return `${selectors}{${properties}}`;\r\n            case \"selector\":\r\n                selectors = rule.selectors\r\n                    .map(selector => {\r\n                        let name = selector.name;\r\n                        if (/:host/.test(selector.name)) {\r\n                            if (selector.args.length) {\r\n                                name = selector.args\r\n                                    .map(arg => `${selector.name}${arg}`)\r\n                                    .join(\",\");\r\n                            }\r\n                        } else if (/:global/.test(selector.name)) {\r\n                            name = selector.args.join(\",\");\r\n                        } else {\r\n                            if (!isKeyframe) {\r\n                                name =\r\n                                    \":host \" +\r\n                                    selector.name +\r\n                                    (selector.args.length > 0\r\n                                        ? `(${selector.args})`\r\n                                        : \"\");\r\n                            }\r\n                        }\r\n                        return name.replace(/:host/g, prefix + id);\r\n                    })\r\n                    .join(\",\");\r\n                properties = rule.properties\r\n                    .map(({ index, value }) => {\r\n                        if (regAn.test(index)) {\r\n                            value = value.replace(/(\\s*)/, id + \"-$1\");\r\n                        }\r\n                        return `${index}:${value}`;\r\n                    })\r\n                    .join(\";\");\r\n\r\n                return `${selectors}{${properties}}`;\r\n            case \"import\":\r\n                return rule.selector + \";\";\r\n            default:\r\n                return \"\";\r\n        }\r\n    });\r\n    if (!deep) {\r\n        let globals = \"\",\r\n            locals = \"\";\r\n        rules.forEach(str => {\r\n            if (regNm.test(str)) {\r\n                locals += str;\r\n            } else {\r\n                globals += str;\r\n            }\r\n        });\r\n        return { globals, locals };\r\n    }\r\n    return rules.join(\"\");\r\n}\r\n\r\nexport function create(pragma) {\r\n    return function styled(tag, keysProps = []) {\r\n        let isFun = typeof tag === \"function\",\r\n            element,\r\n            proto;\r\n        switch (tag) {\r\n            case \"a\":\r\n                element = HTMLLinkElement;\r\n                break;\r\n            case \"svg\":\r\n                element = SVGElement;\r\n                break;\r\n            case \"img\":\r\n                element = HTMLImageElement;\r\n                break;\r\n            case \"button\":\r\n                element = HTMLButtonElement;\r\n                break;\r\n            case \"input\":\r\n                element = HTMLInputElement;\r\n                break;\r\n            default:\r\n                element = HTMLElement;\r\n                break;\r\n        }\r\n        proto = element.prototype;\r\n\r\n        let styleTag = document.createElement(\"style\");\r\n        styleTag.dataset.orby = \"css\";\r\n        document.head.appendChild(styleTag);\r\n\r\n        return function local(template, ...args) {\r\n            let idGlobal = prefix + ++current.index,\r\n                counterLocal = 0;\r\n\r\n            template = template\r\n                .map((string, index) => {\r\n                    if (typeof args[index] === \"function\") {\r\n                        string += /\\:(\\s+)$/.test(string)\r\n                            ? `<<${index}>>`\r\n                            : `<<:${index}>>;`;\r\n                    } else {\r\n                        string += args[index] || \"\";\r\n                    }\r\n                    return string;\r\n                })\r\n                .join(\"\");\r\n            let { globals, locals } = rulesToCss(parse(template), strId, \".\");\r\n\r\n            styleTag.innerHTML = globals.replace(regId, idGlobal);\r\n\r\n            return function component(props, context) {\r\n                let idLocal = idGlobal + \"-\" + counterLocal++,\r\n                    style = locals\r\n                        .replace(\r\n                            /animation(-name){0,1}(\\s*):(\\s*)<<id>>/g,\r\n                            all => all.replace(regId, idGlobal)\r\n                        )\r\n                        .replace(regId, idLocal)\r\n                        .replace(regNm, (all, index, end) => {\r\n                            return args[index](props, context) + (end || \"\");\r\n                        }),\r\n                    nextProps = {\r\n                        class: `${idGlobal} ${idLocal} ${props.class || \"\"}`\r\n                    };\r\n                for (let key in props) {\r\n                    if (\r\n                        isFun ||\r\n                        (key in proto ||\r\n                            typeof props[key] === \"function\" ||\r\n                            keysProps.indexOf(key) > -1)\r\n                    ) {\r\n                        nextProps[key] = props[key];\r\n                    }\r\n                }\r\n                return pragma(\r\n                    tag,\r\n                    nextProps,\r\n                    pragma(\"style\", {}, style),\r\n                    ...props.children\r\n                );\r\n            };\r\n        };\r\n    };\r\n}\r\n"],"names":["trim","str","replace","createType","selector","children","properties","data","type","test","match","selectors","string","prev","name","open","parts","args","i","length","letter","push","mapSelector","parse","currentGroup","current","content","groups","singleQuote","doubleQuote","subGroups","let","index","value","brackets","concat","prefix","regId","regNm","regAn","strId","optimizeRules","rules","locals","globals","lengthProperties","propertiesLocals","propertiesGlobal","Object","rule","rulesToCss","id","deep","isKeyframe","map","arg","join","ref","forEach","create","pragma","tag","keysProps","element","proto","isFun","HTMLLinkElement","SVGElement","HTMLImageElement","HTMLButtonElement","HTMLInputElement","HTMLElement","prototype","styleTag","document","createElement","dataset","orby","head","appendChild","template","idGlobal","counterLocal","innerHTML","props","context","idLocal","style","all","end","nextProps","class","key","indexOf"],"mappings":"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"}