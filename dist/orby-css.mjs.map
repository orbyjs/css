{"version":3,"file":"orby-css.mjs","sources":["../src/parse.js","../src/index.js"],"sourcesContent":["export function trim(str) {\r\n    return str.trim\r\n        ? str.trim()\r\n        : str.replace(/^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g, \"\");\r\n}\r\n\r\nexport function mapSelector(string) {\r\n    string = trim(string);\r\n    let name = \"\",\r\n        open = 0,\r\n        parts = [],\r\n        args = [],\r\n        prev;\r\n    for (let i = 0; i < string.length; i++) {\r\n        let letter = string[i];\r\n        if (letter === \"(\") {\r\n            if (!open++) {\r\n                args = [];\r\n                prev = name;\r\n                name = \"\";\r\n            } else {\r\n                name += letter;\r\n            }\r\n        } else if (letter === \")\") {\r\n            if (!--open) {\r\n                args.push(name);\r\n                parts.push({\r\n                    name: prev,\r\n                    args\r\n                });\r\n                name = \"\";\r\n                args = [];\r\n            } else {\r\n                name += letter;\r\n            }\r\n        } else {\r\n            if (letter === \",\") {\r\n                name && (open ? args.push(name) : parts.push({ name }));\r\n                name = \"\";\r\n            } else {\r\n                name += letter;\r\n            }\r\n        }\r\n    }\r\n    if (name) parts.push({ name, args });\r\n    return parts;\r\n}\r\n\r\nexport function createType(selector) {\r\n    selector = trim(selector);\r\n    let children = [],\r\n        properties = [],\r\n        data = { selector, children, type: \"selector\", properties },\r\n        test = selector.match(/^\\@(\\w+) (.+)/);\r\n\r\n    if (test) {\r\n        let [selector, type, value] = test;\r\n        return { selector, type, value, children, properties };\r\n    } else {\r\n        data.selectors = mapSelector(data.selector);\r\n    }\r\n\r\n    return data;\r\n}\r\n/**\r\n *\r\n * @param {String} str - css rules\r\n * @return {Array}\r\n *\r\n * TODO:\r\n * Add support:\r\n * selector{color:'every:a;{}'}\r\n */\r\nexport function parse(str) {\r\n    let letter,\r\n        current = \"\",\r\n        content = \"\",\r\n        brackets = 0,\r\n        groups = [],\r\n        withSlash,\r\n        currentGroup,\r\n        singleQuote = 0,\r\n        doubleQuote = 0,\r\n        subGroups = [];\r\n\r\n    str = trim(str).replace(/([^\\:]+):([^\\;]+){0,1}}/g, \"$1:$2;}\");\r\n    for (let i = 0; i < str.length; i++) {\r\n        letter = str[i];\r\n\r\n        if (str[i - 1] === \"\\\\\") {\r\n            current += letter;\r\n            continue;\r\n        }\r\n\r\n        if (singleQuote || doubleQuote) {\r\n            current += letter;\r\n            if (letter === \"'\" || letter === '\"') {\r\n                if (letter === \"'\") {\r\n                    singleQuote = false;\r\n                } else {\r\n                    doubleQuote = false;\r\n                }\r\n            }\r\n            continue;\r\n        }\r\n        switch (letter) {\r\n            case \";\":\r\n                if (!/\\{/.test(current)) {\r\n                    current = trim(current);\r\n                    let [all, index, value] =\r\n                        current.match(/^([\\w\\<\\-]+)(?:\\s*):(.+)/) || [];\r\n                    if (index && value) {\r\n                        currentGroup.properties.push({\r\n                            index,\r\n                            value: trim(value)\r\n                        });\r\n                    } else {\r\n                        current && groups.push(createType(current));\r\n                    }\r\n                    current = \"\";\r\n                } else {\r\n                    current += letter;\r\n                }\r\n                break;\r\n            case \"{\":\r\n                if (!brackets++) {\r\n                    currentGroup = createType(current);\r\n                    groups.push(currentGroup);\r\n                    current = \"\";\r\n                } else {\r\n                    current += letter;\r\n                }\r\n                break;\r\n            case \"}\":\r\n                if (!--brackets) {\r\n                    let children = [];\r\n                    for (let i = 0; i < subGroups.length; i++) {\r\n                        children = children.concat(parse(subGroups[i]));\r\n                    }\r\n                    currentGroup.children = children;\r\n                    subGroups = [];\r\n                } else {\r\n                    subGroups.push((current += letter));\r\n                }\r\n                current = \"\";\r\n                break;\r\n            case \"'\":\r\n                singleQuote = true;\r\n                current += letter;\r\n                break;\r\n            case '\"':\r\n                doubleQuote = true;\r\n                current += letter;\r\n                break;\r\n            default:\r\n                current += letter;\r\n        }\r\n    }\r\n    return groups;\r\n}\r\n","import { parse } from \"./parse\";\r\n\r\nlet counter = 0;\r\nlet prefix = \"css-\";\r\nlet regId = /<<id>>/g;\r\nlet regNm = /<<(?:\\:){0,1}(\\d+)>>(\\;){0,1}/g;\r\nlet regAn = /^animation(-name){0,1}$/;\r\nlet strId = \"<<id>>\";\r\n\r\nfunction optimize(rules) {\r\n    let locals = [],\r\n        globals = [];\r\n    for (let i = 0; i < rules.length; i++) {\r\n        let { properties, ...rule } = rules[i],\r\n            lengthProperties = properties.length,\r\n            propertiesLocals = [],\r\n            propertiesGlobal = [];\r\n        for (let i = 0; i < lengthProperties; i++) {\r\n            let { value, index } = properties[i],\r\n                local = false;\r\n\r\n            if (regNm.test(value) || regAn.test(index)) {\r\n                local = true;\r\n                propertiesLocals.push({ value, index });\r\n            } else {\r\n                propertiesGlobal.push({ value, index });\r\n            }\r\n        }\r\n\r\n        if (lengthProperties) {\r\n            if (propertiesLocals.length) {\r\n                locals.push({ ...rule, properties: propertiesLocals });\r\n            }\r\n            if (propertiesGlobal.length) {\r\n                globals.push({ ...rule, properties: propertiesGlobal });\r\n            }\r\n        } else {\r\n            switch (rule.type) {\r\n                case \"media\":\r\n                case \"supports\":\r\n                    let children = optimize(rule.children);\r\n                    locals = locals.concat({\r\n                        ...rule,\r\n                        properties: [],\r\n                        children: children.locals\r\n                    });\r\n                    globals = globals.concat({\r\n                        ...rule,\r\n                        properties: [],\r\n                        children: children.globals\r\n                    });\r\n                    break;\r\n                default:\r\n                    globals.push({ ...rule, properties: [] });\r\n            }\r\n        }\r\n    }\r\n    return { globals, locals };\r\n}\r\n\r\nfunction scoped(rules, id, prefix, deep) {\r\n    if (!deep) {\r\n        let { locals, globals } = optimize(rules);\r\n        rules = locals.concat(globals);\r\n    }\r\n    rules = rules.map(rule => {\r\n        let selectors, properties;\r\n        switch (rule.type) {\r\n            case \"keyframes\":\r\n                selectors = \"@keyframes \" + id + \"-\" + rule.value;\r\n                properties = properties = scoped(rule.children, \"\", \"\", true);\r\n                return `${selectors}{${properties}}`;\r\n            case \"media\":\r\n                selectors = \"@media \" + rule.value;\r\n                properties = scoped(rule.children, id, prefix, true);\r\n                return `${selectors}{${properties}}`;\r\n            case \"selector\":\r\n                selectors = rule.selectors\r\n                    .map(selector => {\r\n                        let name = selector.name;\r\n                        if (/:host/.test(selector.name)) {\r\n                            if (selector.args.length) {\r\n                                name = selector.args\r\n                                    .map(arg => `${selector.name}${arg}`)\r\n                                    .join(\",\");\r\n                            }\r\n                        }\r\n                        if (/:global/.test(selector.name)) {\r\n                            name = selector.args.join(\",\");\r\n                        }\r\n                        return name.replace(/:host/g, prefix + id);\r\n                    })\r\n                    .join(\",\");\r\n                properties = rule.properties\r\n                    .map(({ index, value }) => {\r\n                        if (regAn.test(index)) {\r\n                            value = value.replace(/(\\s*)/, id + \"-$1\");\r\n                        }\r\n                        return `${index}:${value}`;\r\n                    })\r\n                    .join(\";\");\r\n\r\n                return `${selectors}{${properties}}`;\r\n            case \"import\":\r\n                return rule.selector + \";\";\r\n            default:\r\n                return \"\";\r\n        }\r\n    });\r\n    if (!deep) {\r\n        let globals = \"\",\r\n            locals = \"\";\r\n        rules.forEach(str => {\r\n            if (regNm.test(str)) {\r\n                locals += str;\r\n            } else {\r\n                globals += str;\r\n            }\r\n        });\r\n        return { globals, locals };\r\n    }\r\n    return rules.join(\"\");\r\n}\r\n\r\nfunction createGlobal(id, style) {\r\n    let tag = document.querySelector(`style.${id}`);\r\n    if (!tag) {\r\n        tag = document.createElement(\"style\");\r\n        tag.className = id;\r\n        document.head.append(tag);\r\n    }\r\n    tag.innerHTML = style.replace(regId, id);\r\n}\r\n\r\nexport default function create(pragma) {\r\n    return function styled(tag, keysProps = []) {\r\n        let isFun = typeof tag === \"function\",\r\n            element = isFun ? {} : document.createElement(tag);\r\n        return function local(template, ...args) {\r\n            let idGlobal = prefix + counter++,\r\n                counterLocal = 0;\r\n\r\n            template = template\r\n                .map((string, index) => {\r\n                    if (typeof args[index] === \"function\") {\r\n                        string += /\\:(\\s+)$/.test(string)\r\n                            ? `<<${index}>>`\r\n                            : `<<:${index}>>;`;\r\n                    } else {\r\n                        string += args[index] || \"\";\r\n                    }\r\n                    return string;\r\n                })\r\n                .join(\"\");\r\n            let { globals, locals } = scoped(parse(template), strId, \".\");\r\n            createGlobal(idGlobal, globals);\r\n            return function component(props, context, optional) {\r\n                let idLocal = idGlobal + \"-\" + counterLocal++,\r\n                    style = locals\r\n                        .replace(\r\n                            /animation(-name){0,1}(\\s*):(\\s*)<<id>>/g,\r\n                            all => all.replace(regId, idGlobal)\r\n                        )\r\n                        .replace(regId, idLocal)\r\n\r\n                        .replace(regNm, (all, index, end) => {\r\n                            return (\r\n                                args[index](props, optional || context, {\r\n                                    idGlobal,\r\n                                    idLocal\r\n                                }) + (end || \"\")\r\n                            );\r\n                        }),\r\n                    nextProps = {\r\n                        class: `${idGlobal} ${idLocal} ${props.class || \"\"}`\r\n                    };\r\n                for (let key in props) {\r\n                    if (\r\n                        isFun ||\r\n                        (key in element ||\r\n                            typeof props[key] === \"function\" ||\r\n                            keysProps.indexOf(key) > -1)\r\n                    ) {\r\n                        nextProps[key] = props[key];\r\n                    }\r\n                }\r\n                return pragma(\r\n                    tag,\r\n                    nextProps,\r\n                    pragma(\"style\", {}, style),\r\n                    ...props.children\r\n                );\r\n            };\r\n        };\r\n    };\r\n}\r\n"],"names":["trim","str","replace","createType","selector","children","properties","data","type","test","match","selectors","string","prev","name","open","parts","args","i","length","letter","push","mapSelector","let","counter","prefix","regId","regNm","regAn","strId","scoped","rules","id","deep","optimize","locals","globals","lengthProperties","propertiesLocals","propertiesGlobal","value","index","Object","rule","concat","map","arg","join","ref","forEach","pragma","tag","keysProps","isFun","element","document","createElement","template","idGlobal","counterLocal","parse","currentGroup","current","content","groups","singleQuote","doubleQuote","subGroups","brackets","style","querySelector","className","head","append","innerHTML","createGlobal","props","context","optional","idLocal","all","end","nextProps","class","key","indexOf"],"mappings":"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"}